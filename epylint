#! /usr/bin/env python
import ctypes
import errno
import logging
import hashlib
import os
import socket
import sys
import time


LOG_FILE = os.path.expanduser('~/.emacs.d/epylint.log')
SOCK_DIR = os.path.expanduser('~/.emacs.d/epylintd')
TIMEOUT = 5 * 60 * 1000
SCM_RIGHTS = 0x01

class iovec(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('base', ctypes.POINTER(ctypes.c_byte)),
        ('len', ctypes.c_size_t),
    ]

class cmsg(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('len', ctypes.c_size_t),
        ('level', ctypes.c_int),
        ('type', ctypes.c_int),
        ('fd', ctypes.c_int),
    ]

class msghdr(ctypes.Structure):
    _fields_ = [
        ('name', ctypes.c_void_p),
        ('namelen', ctypes.c_uint32),
        ('iov', ctypes.POINTER(iovec)),
        ('iovlen', ctypes.c_size_t),
        ('control', ctypes.POINTER(cmsg)),
        ('controllen', ctypes.c_size_t),
        ('flags', ctypes.c_int),
    ]

class passfd(object):
    libc = ctypes.CDLL("libc.so.6", use_errno=True)

    @staticmethod
    def send(sock, fd):
        iov = iovec(base=ctypes.pointer(ctypes.c_byte(0)), len=1)
        payload = cmsg(len=ctypes.sizeof(cmsg),
                       level=socket.SOL_SOCKET,
                       type=SCM_RIGHTS,
                       fd=fd)
        message = msghdr(iov=ctypes.pointer(iov),
                         iovlen=1,
                         control=ctypes.pointer(payload),
                         controllen=ctypes.sizeof(payload))
        res = passfd.libc.sendmsg(sock.fileno(), ctypes.pointer(message), 0)

        if res != 1:
            errno = ctypes.get_errno()
            raise OSError(errno, os.strerror(errno))

    @staticmethod
    def recv(sock):
        iov = iovec(base=ctypes.pointer(ctypes.c_byte(0)), len=1)
        payload = cmsg(len=ctypes.sizeof(cmsg))
        message = msghdr(iov=ctypes.pointer(iov),
                         iovlen=1,
                         control=ctypes.pointer(payload),
                         controllen=ctypes.sizeof(payload))
        res = passfd.libc.recvmsg(sock.fileno(), ctypes.pointer(message), 0)

        if res == -1:
            error = ctypes.get_errno()
            raise OSError(errno, os.strerror(error))
        elif res == 0:
            return None

        if (payload.level != socket.SOL_SOCKET or
                payload.type != SCM_RIGHTS):
            raise RuntimeError('Unexpected ancillary messages')

        return payload.fd


def get_sock_path():
    python_path = ':'.join(os.path.abspath(path) for path in sys.path)
    return os.path.join(SOCK_DIR, hashlib.sha1(python_path).hexdigest())


# def find_rope(path):
#     parent = os.path.dirname(path)

#     if parent == path:
#         return None
#     else:
#         if os.path.isdir(os.path.join(parent, '.ropeproject')):
#             return parent
#         else:
#             return find_rope(parent)


def epylint_daemon(signal_socket):
    sock_path = get_sock_path()

    import select
    from pylint.lint import Run
    from astroid.builder import MANAGER

    logging.basicConfig(filename=LOG_FILE, level=logging.INFO)
    logger = logging.getLogger('epylint')

    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
    poll = select.poll()

    # from rope.base.prefs import Prefs
    # rope = find_rope(filename)
    # if rope:
    #     prefs = Prefs()
    #     config_file = os.path.join(rope, '.ropeproject', 'config.py')
    #     mod = imp.load_source('rope_config', config_file)
    #     mod.set_prefs(prefs)
    #     sys.path = prefs.get('python_path', []) + [rope] + sys.path

    try:
        os.unlink(sock_path)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise

    server.bind(sock_path)

    try:
        logger.debug('Started daemon')
        server.listen(5)
        signal_socket.send('ok')
        signal_socket.close()

        poll.register(server, select.POLLIN)
        events = poll.poll(60000)

        while events:
            assert len(events) == 1
            assert events[0][0] == server.fileno()

            (client, _) = server.accept()

            start = time.time()
            logger.debug('Client connected')

            fd = passfd.recv(client)
            if fd is None:
                logger('EOF received')
                break

            client_file = client.makefile()
            filename = client_file.readline().decode('utf-8')[:-1]
            basename, _ = os.path.splitext(filename)
            _, basename = os.path.split(basename)
            dot_basename = '.' + basename

            logger.debug('client send file = %s', filename)
            MANAGER.astroid_cache = {
                key: value
                for key, value in MANAGER.astroid_cache.iteritems()
                if key != basename and not key.endswith(dot_basename)
            }

            sys.stdout = os.fdopen(fd, 'w')
            sys.stderr = sys.stdout

            logger.debug('Running pylint')
            run = Run(['--msg-template={path}:{line}:{column}:[{symbol}, {msg_id}] {msg}',
                          '-rn',
                          filename],
                         exit=False)

            sys.stdout.close()
            client_file.write(str(run.linter.msg_status) + '\n')
            client_file.close()
            client.close()

            end = time.time()
            logger.debug('Pylint done, status = %d, time = %.2f',
                         run.linter.msg_status,
                         end - start)

            events = poll.poll(60000)
    except:
        logger.exception('Unexpected exception')
    finally:
        os.unlink(sock_path)
        server.close()
    logger.debug('daemon exiting')


def spawn_daemon():
    parent, child = socket.socketpair()
    pid = os.fork()

    if pid == 0:
        if os.fork() == 0:
            for fd in xrange(0, 1024):
                try:
                    if fd != child.fileno():
                        os.close(fd)
                except OSError:
                    pass

            os.setsid()
            epylint_daemon(child)
            os._exit(0)
        else:
            os._exit(0)
    else:
        child.close()
        msg = parent.recv(1024)
        if msg != 'ok':
            raise RuntimeError('epylint daemon failed to start: ' + repr(msg))


def get_connection(force):
    try:
        os.makedirs(SOCK_DIR)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    sock_path = get_sock_path()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)

    try:
        sock.connect(sock_path)
    except socket.error as e:
        if e.errno in [errno.ENOENT, errno.ECONNREFUSED]:
            if force:
                spawn_daemon()
                sock.connect(sock_path)
            else:
                return None
        else:
            raise

    return sock

if __name__ == '__main__':
    arg = sys.argv[1]

    if arg == '--kill':
        filename = os.path.abspath(sys.argv[2])
        conn = get_connection(False)
    else:
        filename = os.path.abspath(sys.argv[1])
        conn = get_connection(True)
        passfd.send(conn, sys.stdout.fileno())
        conn.send(filename.encode('utf-8') + '\n')
        status = conn.recv(100)
        sys.exit(0 if int(status) == 0 else 1)
