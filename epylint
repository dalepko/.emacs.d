#! /usr/bin/env python
import ctypes
import errno
import hashlib
import os
import socket
import sys


SOCK_DIR = os.path.expanduser('~/.emacs.d/epylintd')
TIMEOUT = 5 * 60 * 1000
SCM_RIGHTS = 0x01

class iovec(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('base', ctypes.POINTER(ctypes.c_byte)),
        ('len', ctypes.c_size_t),
    ]

class cmsg(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ('len', ctypes.c_size_t),
        ('level', ctypes.c_int),
        ('type', ctypes.c_int),
        ('fd', ctypes.c_int),
    ]

class msghdr(ctypes.Structure):
    _fields_ = [
        ('name', ctypes.c_void_p),
        ('namelen', ctypes.c_uint32),
        ('iov', ctypes.POINTER(iovec)),
        ('iovlen', ctypes.c_size_t),
        ('control', ctypes.POINTER(cmsg)),
        ('controllen', ctypes.c_size_t),
        ('flags', ctypes.c_int),
    ]

class passfd(object):
    libc = ctypes.CDLL("libc.so.6", use_errno=True)

    @staticmethod
    def send(sock, fd):
        iov = iovec(base=ctypes.pointer(ctypes.c_byte(0)), len=1)
        payload = cmsg(len=ctypes.sizeof(cmsg),
                       level=socket.SOL_SOCKET,
                       type=SCM_RIGHTS,
                       fd=fd)
        message = msghdr(iov=ctypes.pointer(iov),
                         iovlen=1,
                         control=ctypes.pointer(payload),
                         controllen=ctypes.sizeof(payload))
        res = passfd.libc.sendmsg(sock.fileno(), ctypes.pointer(message), 0)

        if res != 1:
            errno = ctypes.get_errno()
            raise OSError(errno, os.strerror(errno))

    @staticmethod
    def recv(sock):
        iov = iovec(base=ctypes.pointer(ctypes.c_byte(0)), len=1)
        payload = cmsg(len=ctypes.sizeof(cmsg))
        message = msghdr(iov=ctypes.pointer(iov),
                         iovlen=1,
                         control=ctypes.pointer(payload),
                         controllen=ctypes.sizeof(payload))
        res = passfd.libc.recvmsg(sock.fileno(), ctypes.pointer(message), 0)

        if res == -1:
            error = ctypes.get_errno()
            raise OSError(errno, os.strerror(error))

        if (payload.level != socket.SOL_SOCKET or
                payload.type != SCM_RIGHTS):
            raise RuntimeError('Unexpected ancillary messages')

        return payload.fd

def socket_for_file(filename):
    return os.path.join(SOCK_DIR, hashlib.sha1(filename).hexdigest())


def find_rope(path):
    parent = os.path.dirname(path)

    if parent == path:
        return None
    else:
        if os.path.isdir(os.path.join(parent, '.ropeproject')):
            return parent
        else:
            return find_rope(parent)


def epylint_daemon(filename, signal_socket):
    import select
    from pylint.lint import Run

    sock_file = socket_for_file(filename)
    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
    poll = select.poll()
    # from rope.base.prefs import Prefs
    # rope = find_rope(filename)
    # if rope:
    #     prefs = Prefs()
    #     config_file = os.path.join(rope, '.ropeproject', 'config.py')
    #     mod = imp.load_source('rope_config', config_file)
    #     mod.set_prefs(prefs)
    #     sys.path = prefs.get('python_path', []) + [rope] + sys.path

    try:
        os.unlink(sock_file)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise

    server.bind(sock_file)
    try:
        server.listen(5)
        signal_socket.send('ok')
        signal_socket.close()
        sys.stdout.close()
        sys.stderr.close()

        poll.register(server, select.POLLIN)
        events = poll.poll(30000)

        while events:
            assert len(events) == 1
            assert events[0][0] == server.fileno()

            (client, _) = server.accept()
            fd = passfd.recv(client)
            sys.stdout = os.fdopen(fd, 'w')
            sys.stderr = sys.stdout

            Run(['--msg-template={path}:{line}:{column}:[{symbol}, {msg_id}] {msg}',
                 '-rn',
                 filename],
                exit=False)

            sys.stdout.close()
            client.close()

            events = poll.poll(30000)
    finally:
        os.unlink(sock_file)
        server.close()


def spawn_daemon(filename):
    parent, child = socket.socketpair()
    pid = os.fork()

    if pid == 0:
        if os.fork() == 0:
            for fd in xrange(3, 1024):
                try:
                    if fd != child.fileno():
                        os.close(fd)
                except OSError:
                    pass

            os.setsid()
            epylint_daemon(filename, child)
            os._exit(0)
        else:
            os._exit(0)
    else:
        child.close()
        msg = parent.recv(1024)
        if msg != 'ok':
            raise RuntimeError('epylint daemon failed to start: ' + repr(msg))


def get_connection(filename, force):
    try:
        os.makedirs(SOCK_DIR)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    sock_file = os.path.join(SOCK_DIR, hashlib.sha1(filename).hexdigest())
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)

    try:
        sock.connect(sock_file)
    except socket.error as e:
        if e.errno in [errno.ENOENT, errno.ECONNREFUSED]:
            if force:
                spawn_daemon(filename)
                sock.connect(sock_file)
            else:
                return None
        else:
            raise

    return sock

if __name__ == '__main__':
    arg = sys.argv[1]

    if arg == '--kill':
        filename = os.path.abspath(sys.argv[2])
        conn = get_connection(filename, False)
    else:
        filename = os.path.abspath(sys.argv[1])
        conn = get_connection(filename, True)
        passfd.send(conn, sys.stdout.fileno())
        status = conn.recv(1)
